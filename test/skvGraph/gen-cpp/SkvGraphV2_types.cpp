/**
 * Autogenerated by Thrift Compiler (0.16.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "SkvGraphV2_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>



int _kPropertyTypeValues[] = {
  PropertyType::UNKNOWN,
  PropertyType::BOOL,
  PropertyType::INT64,
  PropertyType::VID,
  PropertyType::FLOAT,
  PropertyType::DOUBLE,
  PropertyType::STRING,
  PropertyType::FIXED_STRING,
  PropertyType::INT8,
  PropertyType::INT16,
  PropertyType::INT32,
  PropertyType::TIMESTAMP,
  PropertyType::DATE,
  PropertyType::DATETIME,
  PropertyType::TIME
};
const char* _kPropertyTypeNames[] = {
  "UNKNOWN",
  "BOOL",
  "INT64",
  "VID",
  "FLOAT",
  "DOUBLE",
  "STRING",
  "FIXED_STRING",
  "INT8",
  "INT16",
  "INT32",
  "TIMESTAMP",
  "DATE",
  "DATETIME",
  "TIME"
};
const std::map<int, const char*> _PropertyType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(15, _kPropertyTypeValues, _kPropertyTypeNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const PropertyType::type& val) {
  std::map<int, const char*>::const_iterator it = _PropertyType_VALUES_TO_NAMES.find(val);
  if (it != _PropertyType_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const PropertyType::type& val) {
  std::map<int, const char*>::const_iterator it = _PropertyType_VALUES_TO_NAMES.find(val);
  if (it != _PropertyType_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kErrorCodeValues[] = {
  ErrorCode::SUCCEEDED,
  ErrorCode::E_DISCONNECTED,
  ErrorCode::E_FAIL_TO_CONNECT,
  ErrorCode::E_RPC_FAILURE,
  ErrorCode::E_LEADER_CHANGED,
  ErrorCode::E_NO_HOSTS,
  ErrorCode::E_EXISTED,
  ErrorCode::E_NOT_FOUND,
  ErrorCode::E_INVALID_HOST,
  ErrorCode::E_UNSUPPORTED,
  ErrorCode::E_NOT_DROP,
  ErrorCode::E_BALANCER_RUNNING,
  ErrorCode::E_CONFIG_IMMUTABLE,
  ErrorCode::E_CONFLICT,
  ErrorCode::E_INVALID_PARM,
  ErrorCode::E_WRONGCLUSTER,
  ErrorCode::E_STORE_FAILURE,
  ErrorCode::E_STORE_SEGMENT_ILLEGAL,
  ErrorCode::E_BAD_BALANCE_PLAN,
  ErrorCode::E_BALANCED,
  ErrorCode::E_NO_RUNNING_BALANCE_PLAN,
  ErrorCode::E_NO_VALID_HOST,
  ErrorCode::E_CORRUPTTED_BALANCE_PLAN,
  ErrorCode::E_NO_INVALID_BALANCE_PLAN,
  ErrorCode::E_INVALID_PASSWORD,
  ErrorCode::E_IMPROPER_ROLE,
  ErrorCode::E_INVALID_PARTITION_NUM,
  ErrorCode::E_INVALID_REPLICA_FACTOR,
  ErrorCode::E_INVALID_CHARSET,
  ErrorCode::E_INVALID_COLLATE,
  ErrorCode::E_CHARSET_COLLATE_NOT_MATCH,
  ErrorCode::E_SNAPSHOT_FAILURE,
  ErrorCode::E_BLOCK_WRITE_FAILURE,
  ErrorCode::E_REBUILD_INDEX_FAILURE,
  ErrorCode::E_INDEX_WITH_TTL,
  ErrorCode::E_ADD_JOB_FAILURE,
  ErrorCode::E_STOP_JOB_FAILURE,
  ErrorCode::E_SAVE_JOB_FAILURE,
  ErrorCode::E_BALANCER_FAILURE,
  ErrorCode::E_JOB_NOT_FINISHED,
  ErrorCode::E_TASK_REPORT_OUT_DATE,
  ErrorCode::E_INVALID_JOB,
  ErrorCode::E_BACKUP_FAILURE,
  ErrorCode::E_BACKUP_BUILDING_INDEX,
  ErrorCode::E_BACKUP_SPACE_NOT_FOUND,
  ErrorCode::E_RESTORE_FAILURE,
  ErrorCode::E_UNKNOWN
};
const char* _kErrorCodeNames[] = {
  "SUCCEEDED",
  "E_DISCONNECTED",
  "E_FAIL_TO_CONNECT",
  "E_RPC_FAILURE",
  "E_LEADER_CHANGED",
  "E_NO_HOSTS",
  "E_EXISTED",
  "E_NOT_FOUND",
  "E_INVALID_HOST",
  "E_UNSUPPORTED",
  "E_NOT_DROP",
  "E_BALANCER_RUNNING",
  "E_CONFIG_IMMUTABLE",
  "E_CONFLICT",
  "E_INVALID_PARM",
  "E_WRONGCLUSTER",
  "E_STORE_FAILURE",
  "E_STORE_SEGMENT_ILLEGAL",
  "E_BAD_BALANCE_PLAN",
  "E_BALANCED",
  "E_NO_RUNNING_BALANCE_PLAN",
  "E_NO_VALID_HOST",
  "E_CORRUPTTED_BALANCE_PLAN",
  "E_NO_INVALID_BALANCE_PLAN",
  "E_INVALID_PASSWORD",
  "E_IMPROPER_ROLE",
  "E_INVALID_PARTITION_NUM",
  "E_INVALID_REPLICA_FACTOR",
  "E_INVALID_CHARSET",
  "E_INVALID_COLLATE",
  "E_CHARSET_COLLATE_NOT_MATCH",
  "E_SNAPSHOT_FAILURE",
  "E_BLOCK_WRITE_FAILURE",
  "E_REBUILD_INDEX_FAILURE",
  "E_INDEX_WITH_TTL",
  "E_ADD_JOB_FAILURE",
  "E_STOP_JOB_FAILURE",
  "E_SAVE_JOB_FAILURE",
  "E_BALANCER_FAILURE",
  "E_JOB_NOT_FINISHED",
  "E_TASK_REPORT_OUT_DATE",
  "E_INVALID_JOB",
  "E_BACKUP_FAILURE",
  "E_BACKUP_BUILDING_INDEX",
  "E_BACKUP_SPACE_NOT_FOUND",
  "E_RESTORE_FAILURE",
  "E_UNKNOWN"
};
const std::map<int, const char*> _ErrorCode_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(47, _kErrorCodeValues, _kErrorCodeNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const ErrorCode::type& val) {
  std::map<int, const char*>::const_iterator it = _ErrorCode_VALUES_TO_NAMES.find(val);
  if (it != _ErrorCode_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const ErrorCode::type& val) {
  std::map<int, const char*>::const_iterator it = _ErrorCode_VALUES_TO_NAMES.find(val);
  if (it != _ErrorCode_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}


ID::~ID() noexcept {
}


void ID::__set_space_id(const GraphSpaceID val) {
  this->space_id = val;
__isset.space_id = true;
}

void ID::__set_tag_id(const TagID val) {
  this->tag_id = val;
__isset.tag_id = true;
}
std::ostream& operator<<(std::ostream& out, const ID& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ID::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->space_id);
          this->__isset.space_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->tag_id);
          this->__isset.tag_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ID::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ID");

  if (this->__isset.space_id) {
    xfer += oprot->writeFieldBegin("space_id", ::apache::thrift::protocol::T_I32, 1);
    xfer += oprot->writeI32(this->space_id);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.tag_id) {
    xfer += oprot->writeFieldBegin("tag_id", ::apache::thrift::protocol::T_I32, 2);
    xfer += oprot->writeI32(this->tag_id);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ID &a, ID &b) {
  using ::std::swap;
  swap(a.space_id, b.space_id);
  swap(a.tag_id, b.tag_id);
  swap(a.__isset, b.__isset);
}

ID::ID(const ID& other0) noexcept {
  space_id = other0.space_id;
  tag_id = other0.tag_id;
  __isset = other0.__isset;
}
ID& ID::operator=(const ID& other1) noexcept {
  space_id = other1.space_id;
  tag_id = other1.tag_id;
  __isset = other1.__isset;
  return *this;
}
void ID::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ID(";
  out << "space_id="; (__isset.space_id ? (out << to_string(space_id)) : (out << "<null>"));
  out << ", " << "tag_id="; (__isset.tag_id ? (out << to_string(tag_id)) : (out << "<null>"));
  out << ")";
}


HostAddr::~HostAddr() noexcept {
}


void HostAddr::__set_host(const std::string& val) {
  this->host = val;
}

void HostAddr::__set_port(const Port val) {
  this->port = val;
}
std::ostream& operator<<(std::ostream& out, const HostAddr& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t HostAddr::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->host);
          this->__isset.host = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->port);
          this->__isset.port = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HostAddr::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HostAddr");

  xfer += oprot->writeFieldBegin("host", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->host);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("port", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->port);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(HostAddr &a, HostAddr &b) {
  using ::std::swap;
  swap(a.host, b.host);
  swap(a.port, b.port);
  swap(a.__isset, b.__isset);
}

HostAddr::HostAddr(const HostAddr& other2) {
  host = other2.host;
  port = other2.port;
  __isset = other2.__isset;
}
HostAddr& HostAddr::operator=(const HostAddr& other3) {
  host = other3.host;
  port = other3.port;
  __isset = other3.__isset;
  return *this;
}
void HostAddr::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "HostAddr(";
  out << "host=" << to_string(host);
  out << ", " << "port=" << to_string(port);
  out << ")";
}


ExecResp::~ExecResp() noexcept {
}


void ExecResp::__set_code(const ErrorCode::type val) {
  this->code = val;
}

void ExecResp::__set_id(const ID& val) {
  this->id = val;
}

void ExecResp::__set_leader(const HostAddr& val) {
  this->leader = val;
}
std::ostream& operator<<(std::ostream& out, const ExecResp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ExecResp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast4;
          xfer += iprot->readI32(ecast4);
          this->code = static_cast<ErrorCode::type>(ecast4);
          this->__isset.code = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->id.read(iprot);
          this->__isset.id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->leader.read(iprot);
          this->__isset.leader = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ExecResp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ExecResp");

  xfer += oprot->writeFieldBegin("code", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(static_cast<int32_t>(this->code));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->id.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("leader", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->leader.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ExecResp &a, ExecResp &b) {
  using ::std::swap;
  swap(a.code, b.code);
  swap(a.id, b.id);
  swap(a.leader, b.leader);
  swap(a.__isset, b.__isset);
}

ExecResp::ExecResp(const ExecResp& other5) {
  code = other5.code;
  id = other5.id;
  leader = other5.leader;
  __isset = other5.__isset;
}
ExecResp& ExecResp::operator=(const ExecResp& other6) {
  code = other6.code;
  id = other6.id;
  leader = other6.leader;
  __isset = other6.__isset;
  return *this;
}
void ExecResp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ExecResp(";
  out << "code=" << to_string(code);
  out << ", " << "id=" << to_string(id);
  out << ", " << "leader=" << to_string(leader);
  out << ")";
}


ColumnTypeDef::~ColumnTypeDef() noexcept {
}


void ColumnTypeDef::__set_type(const PropertyType::type val) {
  this->type = val;
}

void ColumnTypeDef::__set_type_length(const int16_t val) {
  this->type_length = val;
__isset.type_length = true;
}
std::ostream& operator<<(std::ostream& out, const ColumnTypeDef& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ColumnTypeDef::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_type = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast7;
          xfer += iprot->readI32(ecast7);
          this->type = static_cast<PropertyType::type>(ecast7);
          isset_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->type_length);
          this->__isset.type_length = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_type)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t ColumnTypeDef::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ColumnTypeDef");

  xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(static_cast<int32_t>(this->type));
  xfer += oprot->writeFieldEnd();

  if (this->__isset.type_length) {
    xfer += oprot->writeFieldBegin("type_length", ::apache::thrift::protocol::T_I16, 2);
    xfer += oprot->writeI16(this->type_length);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ColumnTypeDef &a, ColumnTypeDef &b) {
  using ::std::swap;
  swap(a.type, b.type);
  swap(a.type_length, b.type_length);
  swap(a.__isset, b.__isset);
}

ColumnTypeDef::ColumnTypeDef(const ColumnTypeDef& other8) noexcept {
  type = other8.type;
  type_length = other8.type_length;
  __isset = other8.__isset;
}
ColumnTypeDef& ColumnTypeDef::operator=(const ColumnTypeDef& other9) noexcept {
  type = other9.type;
  type_length = other9.type_length;
  __isset = other9.__isset;
  return *this;
}
void ColumnTypeDef::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ColumnTypeDef(";
  out << "type=" << to_string(type);
  out << ", " << "type_length="; (__isset.type_length ? (out << to_string(type_length)) : (out << "<null>"));
  out << ")";
}


SpaceDesc::~SpaceDesc() noexcept {
}


void SpaceDesc::__set_space_name(const int32_t val) {
  this->space_name = val;
}
std::ostream& operator<<(std::ostream& out, const SpaceDesc& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SpaceDesc::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->space_name);
          this->__isset.space_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SpaceDesc::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SpaceDesc");

  xfer += oprot->writeFieldBegin("space_name", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->space_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SpaceDesc &a, SpaceDesc &b) {
  using ::std::swap;
  swap(a.space_name, b.space_name);
  swap(a.__isset, b.__isset);
}

SpaceDesc::SpaceDesc(const SpaceDesc& other10) noexcept {
  space_name = other10.space_name;
  __isset = other10.__isset;
}
SpaceDesc& SpaceDesc::operator=(const SpaceDesc& other11) noexcept {
  space_name = other11.space_name;
  __isset = other11.__isset;
  return *this;
}
void SpaceDesc::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SpaceDesc(";
  out << "space_name=" << to_string(space_name);
  out << ")";
}


SpaceItem::~SpaceItem() noexcept {
}


void SpaceItem::__set_space_id(const GraphSpaceID val) {
  this->space_id = val;
}

void SpaceItem::__set_properties(const SpaceDesc& val) {
  this->properties = val;
}
std::ostream& operator<<(std::ostream& out, const SpaceItem& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SpaceItem::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->space_id);
          this->__isset.space_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->properties.read(iprot);
          this->__isset.properties = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SpaceItem::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SpaceItem");

  xfer += oprot->writeFieldBegin("space_id", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->space_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("properties", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->properties.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SpaceItem &a, SpaceItem &b) {
  using ::std::swap;
  swap(a.space_id, b.space_id);
  swap(a.properties, b.properties);
  swap(a.__isset, b.__isset);
}

SpaceItem::SpaceItem(const SpaceItem& other12) noexcept {
  space_id = other12.space_id;
  properties = other12.properties;
  __isset = other12.__isset;
}
SpaceItem& SpaceItem::operator=(const SpaceItem& other13) noexcept {
  space_id = other13.space_id;
  properties = other13.properties;
  __isset = other13.__isset;
  return *this;
}
void SpaceItem::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SpaceItem(";
  out << "space_id=" << to_string(space_id);
  out << ", " << "properties=" << to_string(properties);
  out << ")";
}


CreateSpaceReq::~CreateSpaceReq() noexcept {
}


void CreateSpaceReq::__set_properties(const SpaceDesc& val) {
  this->properties = val;
}

void CreateSpaceReq::__set_if_not_exists(const bool val) {
  this->if_not_exists = val;
}
std::ostream& operator<<(std::ostream& out, const CreateSpaceReq& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t CreateSpaceReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->properties.read(iprot);
          this->__isset.properties = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->if_not_exists);
          this->__isset.if_not_exists = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CreateSpaceReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CreateSpaceReq");

  xfer += oprot->writeFieldBegin("properties", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->properties.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("if_not_exists", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->if_not_exists);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CreateSpaceReq &a, CreateSpaceReq &b) {
  using ::std::swap;
  swap(a.properties, b.properties);
  swap(a.if_not_exists, b.if_not_exists);
  swap(a.__isset, b.__isset);
}

CreateSpaceReq::CreateSpaceReq(const CreateSpaceReq& other14) noexcept {
  properties = other14.properties;
  if_not_exists = other14.if_not_exists;
  __isset = other14.__isset;
}
CreateSpaceReq& CreateSpaceReq::operator=(const CreateSpaceReq& other15) noexcept {
  properties = other15.properties;
  if_not_exists = other15.if_not_exists;
  __isset = other15.__isset;
  return *this;
}
void CreateSpaceReq::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CreateSpaceReq(";
  out << "properties=" << to_string(properties);
  out << ", " << "if_not_exists=" << to_string(if_not_exists);
  out << ")";
}


SchemaProp::~SchemaProp() noexcept {
}


void SchemaProp::__set_ttl_duration(const int64_t val) {
  this->ttl_duration = val;
__isset.ttl_duration = true;
}

void SchemaProp::__set_ttl_col(const std::string& val) {
  this->ttl_col = val;
__isset.ttl_col = true;
}

void SchemaProp::__set_comment(const std::string& val) {
  this->comment = val;
__isset.comment = true;
}
std::ostream& operator<<(std::ostream& out, const SchemaProp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SchemaProp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->ttl_duration);
          this->__isset.ttl_duration = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->ttl_col);
          this->__isset.ttl_col = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->comment);
          this->__isset.comment = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SchemaProp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SchemaProp");

  if (this->__isset.ttl_duration) {
    xfer += oprot->writeFieldBegin("ttl_duration", ::apache::thrift::protocol::T_I64, 1);
    xfer += oprot->writeI64(this->ttl_duration);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.ttl_col) {
    xfer += oprot->writeFieldBegin("ttl_col", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeBinary(this->ttl_col);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.comment) {
    xfer += oprot->writeFieldBegin("comment", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeBinary(this->comment);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SchemaProp &a, SchemaProp &b) {
  using ::std::swap;
  swap(a.ttl_duration, b.ttl_duration);
  swap(a.ttl_col, b.ttl_col);
  swap(a.comment, b.comment);
  swap(a.__isset, b.__isset);
}

SchemaProp::SchemaProp(const SchemaProp& other16) {
  ttl_duration = other16.ttl_duration;
  ttl_col = other16.ttl_col;
  comment = other16.comment;
  __isset = other16.__isset;
}
SchemaProp& SchemaProp::operator=(const SchemaProp& other17) {
  ttl_duration = other17.ttl_duration;
  ttl_col = other17.ttl_col;
  comment = other17.comment;
  __isset = other17.__isset;
  return *this;
}
void SchemaProp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SchemaProp(";
  out << "ttl_duration="; (__isset.ttl_duration ? (out << to_string(ttl_duration)) : (out << "<null>"));
  out << ", " << "ttl_col="; (__isset.ttl_col ? (out << to_string(ttl_col)) : (out << "<null>"));
  out << ", " << "comment="; (__isset.comment ? (out << to_string(comment)) : (out << "<null>"));
  out << ")";
}


ColumnDef::~ColumnDef() noexcept {
}


void ColumnDef::__set_name(const std::string& val) {
  this->name = val;
}

void ColumnDef::__set_type(const ColumnTypeDef& val) {
  this->type = val;
}

void ColumnDef::__set_default_value(const std::string& val) {
  this->default_value = val;
__isset.default_value = true;
}

void ColumnDef::__set_nullable(const bool val) {
  this->nullable = val;
__isset.nullable = true;
}

void ColumnDef::__set_comment(const std::string& val) {
  this->comment = val;
__isset.comment = true;
}
std::ostream& operator<<(std::ostream& out, const ColumnDef& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ColumnDef::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_name = false;
  bool isset_type = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->name);
          isset_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->type.read(iprot);
          isset_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->default_value);
          this->__isset.default_value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->nullable);
          this->__isset.nullable = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->comment);
          this->__isset.comment = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_type)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t ColumnDef::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ColumnDef");

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->type.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.default_value) {
    xfer += oprot->writeFieldBegin("default_value", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeBinary(this->default_value);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.nullable) {
    xfer += oprot->writeFieldBegin("nullable", ::apache::thrift::protocol::T_BOOL, 4);
    xfer += oprot->writeBool(this->nullable);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.comment) {
    xfer += oprot->writeFieldBegin("comment", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeBinary(this->comment);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ColumnDef &a, ColumnDef &b) {
  using ::std::swap;
  swap(a.name, b.name);
  swap(a.type, b.type);
  swap(a.default_value, b.default_value);
  swap(a.nullable, b.nullable);
  swap(a.comment, b.comment);
  swap(a.__isset, b.__isset);
}

ColumnDef::ColumnDef(const ColumnDef& other18) {
  name = other18.name;
  type = other18.type;
  default_value = other18.default_value;
  nullable = other18.nullable;
  comment = other18.comment;
  __isset = other18.__isset;
}
ColumnDef& ColumnDef::operator=(const ColumnDef& other19) {
  name = other19.name;
  type = other19.type;
  default_value = other19.default_value;
  nullable = other19.nullable;
  comment = other19.comment;
  __isset = other19.__isset;
  return *this;
}
void ColumnDef::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ColumnDef(";
  out << "name=" << to_string(name);
  out << ", " << "type=" << to_string(type);
  out << ", " << "default_value="; (__isset.default_value ? (out << to_string(default_value)) : (out << "<null>"));
  out << ", " << "nullable="; (__isset.nullable ? (out << to_string(nullable)) : (out << "<null>"));
  out << ", " << "comment="; (__isset.comment ? (out << to_string(comment)) : (out << "<null>"));
  out << ")";
}


