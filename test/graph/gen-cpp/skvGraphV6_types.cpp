/**
 * Autogenerated by Thrift Compiler (0.16.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "skvGraphV6_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>



int _kPropertyTypeValues[] = {
  PropertyType::UNKNOWN,
  PropertyType::BOOL,
  PropertyType::INT64,
  PropertyType::VID,
  PropertyType::FLOAT,
  PropertyType::DOUBLE,
  PropertyType::STRING,
  PropertyType::FIXED_STRING,
  PropertyType::INT8,
  PropertyType::INT16,
  PropertyType::INT32,
  PropertyType::TIMESTAMP,
  PropertyType::DATE,
  PropertyType::DATETIME,
  PropertyType::TIME
};
const char* _kPropertyTypeNames[] = {
  "UNKNOWN",
  "BOOL",
  "INT64",
  "VID",
  "FLOAT",
  "DOUBLE",
  "STRING",
  "FIXED_STRING",
  "INT8",
  "INT16",
  "INT32",
  "TIMESTAMP",
  "DATE",
  "DATETIME",
  "TIME"
};
const std::map<int, const char*> _PropertyType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(15, _kPropertyTypeValues, _kPropertyTypeNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const PropertyType::type& val) {
  std::map<int, const char*>::const_iterator it = _PropertyType_VALUES_TO_NAMES.find(val);
  if (it != _PropertyType_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const PropertyType::type& val) {
  std::map<int, const char*>::const_iterator it = _PropertyType_VALUES_TO_NAMES.find(val);
  if (it != _PropertyType_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kErrorCodeValues[] = {
  ErrorCode::SUCCEEDED,
  ErrorCode::E_DISCONNECTED,
  ErrorCode::E_FAIL_TO_CONNECT,
  ErrorCode::E_RPC_FAILURE,
  ErrorCode::E_LEADER_CHANGED,
  ErrorCode::E_NO_HOSTS,
  ErrorCode::E_EXISTED,
  ErrorCode::E_NOT_FOUND,
  ErrorCode::E_INVALID_HOST,
  ErrorCode::E_UNSUPPORTED,
  ErrorCode::E_NOT_DROP,
  ErrorCode::E_BALANCER_RUNNING,
  ErrorCode::E_CONFIG_IMMUTABLE,
  ErrorCode::E_CONFLICT,
  ErrorCode::E_INVALID_PARM,
  ErrorCode::E_WRONGCLUSTER,
  ErrorCode::E_STORE_FAILURE,
  ErrorCode::E_STORE_SEGMENT_ILLEGAL,
  ErrorCode::E_BAD_BALANCE_PLAN,
  ErrorCode::E_BALANCED,
  ErrorCode::E_NO_RUNNING_BALANCE_PLAN,
  ErrorCode::E_NO_VALID_HOST,
  ErrorCode::E_CORRUPTTED_BALANCE_PLAN,
  ErrorCode::E_NO_INVALID_BALANCE_PLAN,
  ErrorCode::E_INVALID_PASSWORD,
  ErrorCode::E_IMPROPER_ROLE,
  ErrorCode::E_INVALID_PARTITION_NUM,
  ErrorCode::E_INVALID_REPLICA_FACTOR,
  ErrorCode::E_INVALID_CHARSET,
  ErrorCode::E_INVALID_COLLATE,
  ErrorCode::E_CHARSET_COLLATE_NOT_MATCH,
  ErrorCode::E_SNAPSHOT_FAILURE,
  ErrorCode::E_BLOCK_WRITE_FAILURE,
  ErrorCode::E_REBUILD_INDEX_FAILURE,
  ErrorCode::E_INDEX_WITH_TTL,
  ErrorCode::E_ADD_JOB_FAILURE,
  ErrorCode::E_STOP_JOB_FAILURE,
  ErrorCode::E_SAVE_JOB_FAILURE,
  ErrorCode::E_BALANCER_FAILURE,
  ErrorCode::E_JOB_NOT_FINISHED,
  ErrorCode::E_TASK_REPORT_OUT_DATE,
  ErrorCode::E_INVALID_JOB,
  ErrorCode::E_BACKUP_FAILURE,
  ErrorCode::E_BACKUP_BUILDING_INDEX,
  ErrorCode::E_BACKUP_SPACE_NOT_FOUND,
  ErrorCode::E_RESTORE_FAILURE,
  ErrorCode::E_UNKNOWN
};
const char* _kErrorCodeNames[] = {
  "SUCCEEDED",
  "E_DISCONNECTED",
  "E_FAIL_TO_CONNECT",
  "E_RPC_FAILURE",
  "E_LEADER_CHANGED",
  "E_NO_HOSTS",
  "E_EXISTED",
  "E_NOT_FOUND",
  "E_INVALID_HOST",
  "E_UNSUPPORTED",
  "E_NOT_DROP",
  "E_BALANCER_RUNNING",
  "E_CONFIG_IMMUTABLE",
  "E_CONFLICT",
  "E_INVALID_PARM",
  "E_WRONGCLUSTER",
  "E_STORE_FAILURE",
  "E_STORE_SEGMENT_ILLEGAL",
  "E_BAD_BALANCE_PLAN",
  "E_BALANCED",
  "E_NO_RUNNING_BALANCE_PLAN",
  "E_NO_VALID_HOST",
  "E_CORRUPTTED_BALANCE_PLAN",
  "E_NO_INVALID_BALANCE_PLAN",
  "E_INVALID_PASSWORD",
  "E_IMPROPER_ROLE",
  "E_INVALID_PARTITION_NUM",
  "E_INVALID_REPLICA_FACTOR",
  "E_INVALID_CHARSET",
  "E_INVALID_COLLATE",
  "E_CHARSET_COLLATE_NOT_MATCH",
  "E_SNAPSHOT_FAILURE",
  "E_BLOCK_WRITE_FAILURE",
  "E_REBUILD_INDEX_FAILURE",
  "E_INDEX_WITH_TTL",
  "E_ADD_JOB_FAILURE",
  "E_STOP_JOB_FAILURE",
  "E_SAVE_JOB_FAILURE",
  "E_BALANCER_FAILURE",
  "E_JOB_NOT_FINISHED",
  "E_TASK_REPORT_OUT_DATE",
  "E_INVALID_JOB",
  "E_BACKUP_FAILURE",
  "E_BACKUP_BUILDING_INDEX",
  "E_BACKUP_SPACE_NOT_FOUND",
  "E_RESTORE_FAILURE",
  "E_UNKNOWN"
};
const std::map<int, const char*> _ErrorCode_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(47, _kErrorCodeValues, _kErrorCodeNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const ErrorCode::type& val) {
  std::map<int, const char*>::const_iterator it = _ErrorCode_VALUES_TO_NAMES.find(val);
  if (it != _ErrorCode_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const ErrorCode::type& val) {
  std::map<int, const char*>::const_iterator it = _ErrorCode_VALUES_TO_NAMES.find(val);
  if (it != _ErrorCode_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kNullTypeValues[] = {
  NullType::__NULL__,
  NullType::NaN,
  NullType::BAD_DATA,
  NullType::BAD_TYPE,
  NullType::ERR_OVERFLOW,
  NullType::UNKNOWN_PROP,
  NullType::DIV_BY_ZERO,
  NullType::OUT_OF_RANGE
};
const char* _kNullTypeNames[] = {
  "__NULL__",
  "NaN",
  "BAD_DATA",
  "BAD_TYPE",
  "ERR_OVERFLOW",
  "UNKNOWN_PROP",
  "DIV_BY_ZERO",
  "OUT_OF_RANGE"
};
const std::map<int, const char*> _NullType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(8, _kNullTypeValues, _kNullTypeNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const NullType::type& val) {
  std::map<int, const char*>::const_iterator it = _NullType_VALUES_TO_NAMES.find(val);
  if (it != _NullType_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const NullType::type& val) {
  std::map<int, const char*>::const_iterator it = _NullType_VALUES_TO_NAMES.find(val);
  if (it != _NullType_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}


ID::~ID() noexcept {
}


void ID::__set_space_id(const GraphSpaceID val) {
  this->space_id = val;
__isset.space_id = true;
}

void ID::__set_tag_id(const TagID val) {
  this->tag_id = val;
__isset.tag_id = true;
}
std::ostream& operator<<(std::ostream& out, const ID& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ID::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->space_id);
          this->__isset.space_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->tag_id);
          this->__isset.tag_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ID::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ID");

  if (this->__isset.space_id) {
    xfer += oprot->writeFieldBegin("space_id", ::apache::thrift::protocol::T_I32, 1);
    xfer += oprot->writeI32(this->space_id);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.tag_id) {
    xfer += oprot->writeFieldBegin("tag_id", ::apache::thrift::protocol::T_I32, 2);
    xfer += oprot->writeI32(this->tag_id);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ID &a, ID &b) {
  using ::std::swap;
  swap(a.space_id, b.space_id);
  swap(a.tag_id, b.tag_id);
  swap(a.__isset, b.__isset);
}

ID::ID(const ID& other0) noexcept {
  space_id = other0.space_id;
  tag_id = other0.tag_id;
  __isset = other0.__isset;
}
ID& ID::operator=(const ID& other1) noexcept {
  space_id = other1.space_id;
  tag_id = other1.tag_id;
  __isset = other1.__isset;
  return *this;
}
void ID::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ID(";
  out << "space_id="; (__isset.space_id ? (out << to_string(space_id)) : (out << "<null>"));
  out << ", " << "tag_id="; (__isset.tag_id ? (out << to_string(tag_id)) : (out << "<null>"));
  out << ")";
}


HostAddr::~HostAddr() noexcept {
}


void HostAddr::__set_host(const std::string& val) {
  this->host = val;
}

void HostAddr::__set_port(const Port val) {
  this->port = val;
}
std::ostream& operator<<(std::ostream& out, const HostAddr& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t HostAddr::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->host);
          this->__isset.host = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->port);
          this->__isset.port = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HostAddr::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HostAddr");

  xfer += oprot->writeFieldBegin("host", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->host);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("port", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->port);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(HostAddr &a, HostAddr &b) {
  using ::std::swap;
  swap(a.host, b.host);
  swap(a.port, b.port);
  swap(a.__isset, b.__isset);
}

HostAddr::HostAddr(const HostAddr& other2) {
  host = other2.host;
  port = other2.port;
  __isset = other2.__isset;
}
HostAddr& HostAddr::operator=(const HostAddr& other3) {
  host = other3.host;
  port = other3.port;
  __isset = other3.__isset;
  return *this;
}
void HostAddr::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "HostAddr(";
  out << "host=" << to_string(host);
  out << ", " << "port=" << to_string(port);
  out << ")";
}


ExecResp::~ExecResp() noexcept {
}


void ExecResp::__set_code(const ErrorCode::type val) {
  this->code = val;
}

void ExecResp::__set_id(const ID& val) {
  this->id = val;
}
std::ostream& operator<<(std::ostream& out, const ExecResp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ExecResp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast4;
          xfer += iprot->readI32(ecast4);
          this->code = static_cast<ErrorCode::type>(ecast4);
          this->__isset.code = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->id.read(iprot);
          this->__isset.id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ExecResp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ExecResp");

  xfer += oprot->writeFieldBegin("code", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(static_cast<int32_t>(this->code));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->id.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ExecResp &a, ExecResp &b) {
  using ::std::swap;
  swap(a.code, b.code);
  swap(a.id, b.id);
  swap(a.__isset, b.__isset);
}

ExecResp::ExecResp(const ExecResp& other5) noexcept {
  code = other5.code;
  id = other5.id;
  __isset = other5.__isset;
}
ExecResp& ExecResp::operator=(const ExecResp& other6) noexcept {
  code = other6.code;
  id = other6.id;
  __isset = other6.__isset;
  return *this;
}
void ExecResp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ExecResp(";
  out << "code=" << to_string(code);
  out << ", " << "id=" << to_string(id);
  out << ")";
}


ColumnTypeDef::~ColumnTypeDef() noexcept {
}


void ColumnTypeDef::__set_type(const PropertyType::type val) {
  this->type = val;
}

void ColumnTypeDef::__set_type_length(const int16_t val) {
  this->type_length = val;
__isset.type_length = true;
}
std::ostream& operator<<(std::ostream& out, const ColumnTypeDef& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ColumnTypeDef::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_type = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast7;
          xfer += iprot->readI32(ecast7);
          this->type = static_cast<PropertyType::type>(ecast7);
          isset_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->type_length);
          this->__isset.type_length = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_type)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t ColumnTypeDef::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ColumnTypeDef");

  xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(static_cast<int32_t>(this->type));
  xfer += oprot->writeFieldEnd();

  if (this->__isset.type_length) {
    xfer += oprot->writeFieldBegin("type_length", ::apache::thrift::protocol::T_I16, 2);
    xfer += oprot->writeI16(this->type_length);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ColumnTypeDef &a, ColumnTypeDef &b) {
  using ::std::swap;
  swap(a.type, b.type);
  swap(a.type_length, b.type_length);
  swap(a.__isset, b.__isset);
}

ColumnTypeDef::ColumnTypeDef(const ColumnTypeDef& other8) noexcept {
  type = other8.type;
  type_length = other8.type_length;
  __isset = other8.__isset;
}
ColumnTypeDef& ColumnTypeDef::operator=(const ColumnTypeDef& other9) noexcept {
  type = other9.type;
  type_length = other9.type_length;
  __isset = other9.__isset;
  return *this;
}
void ColumnTypeDef::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ColumnTypeDef(";
  out << "type=" << to_string(type);
  out << ", " << "type_length="; (__isset.type_length ? (out << to_string(type_length)) : (out << "<null>"));
  out << ")";
}


SpaceDesc::~SpaceDesc() noexcept {
}


void SpaceDesc::__set_space_name(const std::string& val) {
  this->space_name = val;
}
std::ostream& operator<<(std::ostream& out, const SpaceDesc& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SpaceDesc::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->space_name);
          this->__isset.space_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SpaceDesc::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SpaceDesc");

  xfer += oprot->writeFieldBegin("space_name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->space_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SpaceDesc &a, SpaceDesc &b) {
  using ::std::swap;
  swap(a.space_name, b.space_name);
  swap(a.__isset, b.__isset);
}

SpaceDesc::SpaceDesc(const SpaceDesc& other10) {
  space_name = other10.space_name;
  __isset = other10.__isset;
}
SpaceDesc& SpaceDesc::operator=(const SpaceDesc& other11) {
  space_name = other11.space_name;
  __isset = other11.__isset;
  return *this;
}
void SpaceDesc::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SpaceDesc(";
  out << "space_name=" << to_string(space_name);
  out << ")";
}


SpaceItem::~SpaceItem() noexcept {
}


void SpaceItem::__set_space_id(const GraphSpaceID val) {
  this->space_id = val;
}

void SpaceItem::__set_properties(const SpaceDesc& val) {
  this->properties = val;
}
std::ostream& operator<<(std::ostream& out, const SpaceItem& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SpaceItem::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->space_id);
          this->__isset.space_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->properties.read(iprot);
          this->__isset.properties = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SpaceItem::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SpaceItem");

  xfer += oprot->writeFieldBegin("space_id", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->space_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("properties", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->properties.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SpaceItem &a, SpaceItem &b) {
  using ::std::swap;
  swap(a.space_id, b.space_id);
  swap(a.properties, b.properties);
  swap(a.__isset, b.__isset);
}

SpaceItem::SpaceItem(const SpaceItem& other12) {
  space_id = other12.space_id;
  properties = other12.properties;
  __isset = other12.__isset;
}
SpaceItem& SpaceItem::operator=(const SpaceItem& other13) {
  space_id = other13.space_id;
  properties = other13.properties;
  __isset = other13.__isset;
  return *this;
}
void SpaceItem::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SpaceItem(";
  out << "space_id=" << to_string(space_id);
  out << ", " << "properties=" << to_string(properties);
  out << ")";
}


CreateSpaceReq::~CreateSpaceReq() noexcept {
}


void CreateSpaceReq::__set_properties(const SpaceDesc& val) {
  this->properties = val;
}

void CreateSpaceReq::__set_if_not_exists(const bool val) {
  this->if_not_exists = val;
}
std::ostream& operator<<(std::ostream& out, const CreateSpaceReq& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t CreateSpaceReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->properties.read(iprot);
          this->__isset.properties = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->if_not_exists);
          this->__isset.if_not_exists = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CreateSpaceReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CreateSpaceReq");

  xfer += oprot->writeFieldBegin("properties", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->properties.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("if_not_exists", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->if_not_exists);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CreateSpaceReq &a, CreateSpaceReq &b) {
  using ::std::swap;
  swap(a.properties, b.properties);
  swap(a.if_not_exists, b.if_not_exists);
  swap(a.__isset, b.__isset);
}

CreateSpaceReq::CreateSpaceReq(const CreateSpaceReq& other14) {
  properties = other14.properties;
  if_not_exists = other14.if_not_exists;
  __isset = other14.__isset;
}
CreateSpaceReq& CreateSpaceReq::operator=(const CreateSpaceReq& other15) {
  properties = other15.properties;
  if_not_exists = other15.if_not_exists;
  __isset = other15.__isset;
  return *this;
}
void CreateSpaceReq::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CreateSpaceReq(";
  out << "properties=" << to_string(properties);
  out << ", " << "if_not_exists=" << to_string(if_not_exists);
  out << ")";
}


SchemaProp::~SchemaProp() noexcept {
}


void SchemaProp::__set_ttl_duration(const int64_t val) {
  this->ttl_duration = val;
__isset.ttl_duration = true;
}

void SchemaProp::__set_ttl_col(const std::string& val) {
  this->ttl_col = val;
__isset.ttl_col = true;
}

void SchemaProp::__set_comment(const std::string& val) {
  this->comment = val;
__isset.comment = true;
}
std::ostream& operator<<(std::ostream& out, const SchemaProp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SchemaProp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->ttl_duration);
          this->__isset.ttl_duration = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->ttl_col);
          this->__isset.ttl_col = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->comment);
          this->__isset.comment = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SchemaProp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SchemaProp");

  if (this->__isset.ttl_duration) {
    xfer += oprot->writeFieldBegin("ttl_duration", ::apache::thrift::protocol::T_I64, 1);
    xfer += oprot->writeI64(this->ttl_duration);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.ttl_col) {
    xfer += oprot->writeFieldBegin("ttl_col", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeBinary(this->ttl_col);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.comment) {
    xfer += oprot->writeFieldBegin("comment", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeBinary(this->comment);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SchemaProp &a, SchemaProp &b) {
  using ::std::swap;
  swap(a.ttl_duration, b.ttl_duration);
  swap(a.ttl_col, b.ttl_col);
  swap(a.comment, b.comment);
  swap(a.__isset, b.__isset);
}

SchemaProp::SchemaProp(const SchemaProp& other16) {
  ttl_duration = other16.ttl_duration;
  ttl_col = other16.ttl_col;
  comment = other16.comment;
  __isset = other16.__isset;
}
SchemaProp& SchemaProp::operator=(const SchemaProp& other17) {
  ttl_duration = other17.ttl_duration;
  ttl_col = other17.ttl_col;
  comment = other17.comment;
  __isset = other17.__isset;
  return *this;
}
void SchemaProp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SchemaProp(";
  out << "ttl_duration="; (__isset.ttl_duration ? (out << to_string(ttl_duration)) : (out << "<null>"));
  out << ", " << "ttl_col="; (__isset.ttl_col ? (out << to_string(ttl_col)) : (out << "<null>"));
  out << ", " << "comment="; (__isset.comment ? (out << to_string(comment)) : (out << "<null>"));
  out << ")";
}


ColumnDef::~ColumnDef() noexcept {
}


void ColumnDef::__set_name(const std::string& val) {
  this->name = val;
}

void ColumnDef::__set_type(const ColumnTypeDef& val) {
  this->type = val;
}

void ColumnDef::__set_default_value(const std::string& val) {
  this->default_value = val;
__isset.default_value = true;
}

void ColumnDef::__set_nullable(const bool val) {
  this->nullable = val;
__isset.nullable = true;
}

void ColumnDef::__set_comment(const std::string& val) {
  this->comment = val;
__isset.comment = true;
}
std::ostream& operator<<(std::ostream& out, const ColumnDef& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ColumnDef::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_name = false;
  bool isset_type = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->name);
          isset_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->type.read(iprot);
          isset_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->default_value);
          this->__isset.default_value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->nullable);
          this->__isset.nullable = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->comment);
          this->__isset.comment = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_type)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t ColumnDef::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ColumnDef");

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->type.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.default_value) {
    xfer += oprot->writeFieldBegin("default_value", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeBinary(this->default_value);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.nullable) {
    xfer += oprot->writeFieldBegin("nullable", ::apache::thrift::protocol::T_BOOL, 4);
    xfer += oprot->writeBool(this->nullable);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.comment) {
    xfer += oprot->writeFieldBegin("comment", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeBinary(this->comment);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ColumnDef &a, ColumnDef &b) {
  using ::std::swap;
  swap(a.name, b.name);
  swap(a.type, b.type);
  swap(a.default_value, b.default_value);
  swap(a.nullable, b.nullable);
  swap(a.comment, b.comment);
  swap(a.__isset, b.__isset);
}

ColumnDef::ColumnDef(const ColumnDef& other18) {
  name = other18.name;
  type = other18.type;
  default_value = other18.default_value;
  nullable = other18.nullable;
  comment = other18.comment;
  __isset = other18.__isset;
}
ColumnDef& ColumnDef::operator=(const ColumnDef& other19) {
  name = other19.name;
  type = other19.type;
  default_value = other19.default_value;
  nullable = other19.nullable;
  comment = other19.comment;
  __isset = other19.__isset;
  return *this;
}
void ColumnDef::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ColumnDef(";
  out << "name=" << to_string(name);
  out << ", " << "type=" << to_string(type);
  out << ", " << "default_value="; (__isset.default_value ? (out << to_string(default_value)) : (out << "<null>"));
  out << ", " << "nullable="; (__isset.nullable ? (out << to_string(nullable)) : (out << "<null>"));
  out << ", " << "comment="; (__isset.comment ? (out << to_string(comment)) : (out << "<null>"));
  out << ")";
}


SKVGraphSchema::~SKVGraphSchema() noexcept {
}


void SKVGraphSchema::__set_columns(const std::vector<ColumnDef> & val) {
  this->columns = val;
}

void SKVGraphSchema::__set_schema_prop(const SchemaProp& val) {
  this->schema_prop = val;
__isset.schema_prop = true;
}
std::ostream& operator<<(std::ostream& out, const SKVGraphSchema& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SKVGraphSchema::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->columns.clear();
            uint32_t _size20;
            ::apache::thrift::protocol::TType _etype23;
            xfer += iprot->readListBegin(_etype23, _size20);
            this->columns.resize(_size20);
            uint32_t _i24;
            for (_i24 = 0; _i24 < _size20; ++_i24)
            {
              xfer += this->columns[_i24].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.columns = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->schema_prop.read(iprot);
          this->__isset.schema_prop = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SKVGraphSchema::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SKVGraphSchema");

  xfer += oprot->writeFieldBegin("columns", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->columns.size()));
    std::vector<ColumnDef> ::const_iterator _iter25;
    for (_iter25 = this->columns.begin(); _iter25 != this->columns.end(); ++_iter25)
    {
      xfer += (*_iter25).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.schema_prop) {
    xfer += oprot->writeFieldBegin("schema_prop", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->schema_prop.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SKVGraphSchema &a, SKVGraphSchema &b) {
  using ::std::swap;
  swap(a.columns, b.columns);
  swap(a.schema_prop, b.schema_prop);
  swap(a.__isset, b.__isset);
}

SKVGraphSchema::SKVGraphSchema(const SKVGraphSchema& other26) {
  columns = other26.columns;
  schema_prop = other26.schema_prop;
  __isset = other26.__isset;
}
SKVGraphSchema& SKVGraphSchema::operator=(const SKVGraphSchema& other27) {
  columns = other27.columns;
  schema_prop = other27.schema_prop;
  __isset = other27.__isset;
  return *this;
}
void SKVGraphSchema::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SKVGraphSchema(";
  out << "columns=" << to_string(columns);
  out << ", " << "schema_prop="; (__isset.schema_prop ? (out << to_string(schema_prop)) : (out << "<null>"));
  out << ")";
}


CreateTagReq::~CreateTagReq() noexcept {
}


void CreateTagReq::__set_space_id(const GraphSpaceID val) {
  this->space_id = val;
}

void CreateTagReq::__set_tag_name(const std::string& val) {
  this->tag_name = val;
}

void CreateTagReq::__set_skv_graph_schema(const SKVGraphSchema& val) {
  this->skv_graph_schema = val;
}

void CreateTagReq::__set_if_not_exists(const bool val) {
  this->if_not_exists = val;
}
std::ostream& operator<<(std::ostream& out, const CreateTagReq& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t CreateTagReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->space_id);
          this->__isset.space_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->tag_name);
          this->__isset.tag_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->skv_graph_schema.read(iprot);
          this->__isset.skv_graph_schema = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->if_not_exists);
          this->__isset.if_not_exists = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CreateTagReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CreateTagReq");

  xfer += oprot->writeFieldBegin("space_id", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->space_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tag_name", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeBinary(this->tag_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("skv_graph_schema", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->skv_graph_schema.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("if_not_exists", ::apache::thrift::protocol::T_BOOL, 4);
  xfer += oprot->writeBool(this->if_not_exists);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CreateTagReq &a, CreateTagReq &b) {
  using ::std::swap;
  swap(a.space_id, b.space_id);
  swap(a.tag_name, b.tag_name);
  swap(a.skv_graph_schema, b.skv_graph_schema);
  swap(a.if_not_exists, b.if_not_exists);
  swap(a.__isset, b.__isset);
}

CreateTagReq::CreateTagReq(const CreateTagReq& other28) {
  space_id = other28.space_id;
  tag_name = other28.tag_name;
  skv_graph_schema = other28.skv_graph_schema;
  if_not_exists = other28.if_not_exists;
  __isset = other28.__isset;
}
CreateTagReq& CreateTagReq::operator=(const CreateTagReq& other29) {
  space_id = other29.space_id;
  tag_name = other29.tag_name;
  skv_graph_schema = other29.skv_graph_schema;
  if_not_exists = other29.if_not_exists;
  __isset = other29.__isset;
  return *this;
}
void CreateTagReq::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CreateTagReq(";
  out << "space_id=" << to_string(space_id);
  out << ", " << "tag_name=" << to_string(tag_name);
  out << ", " << "skv_graph_schema=" << to_string(skv_graph_schema);
  out << ", " << "if_not_exists=" << to_string(if_not_exists);
  out << ")";
}


PartitionResult::~PartitionResult() noexcept {
}


void PartitionResult::__set_code(const ErrorCode::type val) {
  this->code = val;
}

void PartitionResult::__set_part_id(const PartitionID val) {
  this->part_id = val;
}
std::ostream& operator<<(std::ostream& out, const PartitionResult& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t PartitionResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_code = false;
  bool isset_part_id = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast30;
          xfer += iprot->readI32(ecast30);
          this->code = static_cast<ErrorCode::type>(ecast30);
          isset_code = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->part_id);
          isset_part_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_code)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_part_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t PartitionResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("PartitionResult");

  xfer += oprot->writeFieldBegin("code", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(static_cast<int32_t>(this->code));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("part_id", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->part_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(PartitionResult &a, PartitionResult &b) {
  using ::std::swap;
  swap(a.code, b.code);
  swap(a.part_id, b.part_id);
}

PartitionResult::PartitionResult(const PartitionResult& other31) noexcept {
  code = other31.code;
  part_id = other31.part_id;
}
PartitionResult& PartitionResult::operator=(const PartitionResult& other32) noexcept {
  code = other32.code;
  part_id = other32.part_id;
  return *this;
}
void PartitionResult::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "PartitionResult(";
  out << "code=" << to_string(code);
  out << ", " << "part_id=" << to_string(part_id);
  out << ")";
}


ResponseCommon::~ResponseCommon() noexcept {
}


void ResponseCommon::__set_failed_parts(const std::vector<PartitionResult> & val) {
  this->failed_parts = val;
}

void ResponseCommon::__set_latency_in_us(const int32_t val) {
  this->latency_in_us = val;
}
std::ostream& operator<<(std::ostream& out, const ResponseCommon& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ResponseCommon::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_failed_parts = false;
  bool isset_latency_in_us = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->failed_parts.clear();
            uint32_t _size33;
            ::apache::thrift::protocol::TType _etype36;
            xfer += iprot->readListBegin(_etype36, _size33);
            this->failed_parts.resize(_size33);
            uint32_t _i37;
            for (_i37 = 0; _i37 < _size33; ++_i37)
            {
              xfer += this->failed_parts[_i37].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_failed_parts = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->latency_in_us);
          isset_latency_in_us = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_failed_parts)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_latency_in_us)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t ResponseCommon::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ResponseCommon");

  xfer += oprot->writeFieldBegin("failed_parts", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->failed_parts.size()));
    std::vector<PartitionResult> ::const_iterator _iter38;
    for (_iter38 = this->failed_parts.begin(); _iter38 != this->failed_parts.end(); ++_iter38)
    {
      xfer += (*_iter38).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("latency_in_us", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->latency_in_us);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ResponseCommon &a, ResponseCommon &b) {
  using ::std::swap;
  swap(a.failed_parts, b.failed_parts);
  swap(a.latency_in_us, b.latency_in_us);
}

ResponseCommon::ResponseCommon(const ResponseCommon& other39) {
  failed_parts = other39.failed_parts;
  latency_in_us = other39.latency_in_us;
}
ResponseCommon& ResponseCommon::operator=(const ResponseCommon& other40) {
  failed_parts = other40.failed_parts;
  latency_in_us = other40.latency_in_us;
  return *this;
}
void ResponseCommon::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ResponseCommon(";
  out << "failed_parts=" << to_string(failed_parts);
  out << ", " << "latency_in_us=" << to_string(latency_in_us);
  out << ")";
}


ExecResponse::~ExecResponse() noexcept {
}


void ExecResponse::__set_code(const ErrorCode::type val) {
  this->code = val;
}
std::ostream& operator<<(std::ostream& out, const ExecResponse& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ExecResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_code = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast41;
          xfer += iprot->readI32(ecast41);
          this->code = static_cast<ErrorCode::type>(ecast41);
          isset_code = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_code)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t ExecResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ExecResponse");

  xfer += oprot->writeFieldBegin("code", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(static_cast<int32_t>(this->code));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ExecResponse &a, ExecResponse &b) {
  using ::std::swap;
  swap(a.code, b.code);
}

ExecResponse::ExecResponse(const ExecResponse& other42) noexcept {
  code = other42.code;
}
ExecResponse& ExecResponse::operator=(const ExecResponse& other43) noexcept {
  code = other43.code;
  return *this;
}
void ExecResponse::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ExecResponse(";
  out << "code=" << to_string(code);
  out << ")";
}


Value::~Value() noexcept {
}


void Value::__set_nVal(const NullType::type val) {
  this->nVal = val;
__isset.nVal = true;
}

void Value::__set_bVal(const bool val) {
  this->bVal = val;
__isset.bVal = true;
}

void Value::__set_iVal(const int64_t val) {
  this->iVal = val;
__isset.iVal = true;
}

void Value::__set_fVal(const double val) {
  this->fVal = val;
__isset.fVal = true;
}

void Value::__set_sVal(const std::string& val) {
  this->sVal = val;
__isset.sVal = true;
}

void Value::__set_wVal(const int32_t val) {
  this->wVal = val;
__isset.wVal = true;
}

void Value::__set_hwVal(const int16_t val) {
  this->hwVal = val;
__isset.hwVal = true;
}
std::ostream& operator<<(std::ostream& out, const Value& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t Value::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast44;
          xfer += iprot->readI32(ecast44);
          this->nVal = static_cast<NullType::type>(ecast44);
          this->__isset.nVal = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->bVal);
          this->__isset.bVal = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->iVal);
          this->__isset.iVal = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->fVal);
          this->__isset.fVal = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->sVal);
          this->__isset.sVal = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->wVal);
          this->__isset.wVal = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->hwVal);
          this->__isset.hwVal = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Value::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Value");

  if (this->__isset.nVal) {
    xfer += oprot->writeFieldBegin("nVal", ::apache::thrift::protocol::T_I32, 1);
    xfer += oprot->writeI32(static_cast<int32_t>(this->nVal));
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.bVal) {
    xfer += oprot->writeFieldBegin("bVal", ::apache::thrift::protocol::T_BOOL, 2);
    xfer += oprot->writeBool(this->bVal);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.iVal) {
    xfer += oprot->writeFieldBegin("iVal", ::apache::thrift::protocol::T_I64, 3);
    xfer += oprot->writeI64(this->iVal);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.fVal) {
    xfer += oprot->writeFieldBegin("fVal", ::apache::thrift::protocol::T_DOUBLE, 4);
    xfer += oprot->writeDouble(this->fVal);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.sVal) {
    xfer += oprot->writeFieldBegin("sVal", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeBinary(this->sVal);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.wVal) {
    xfer += oprot->writeFieldBegin("wVal", ::apache::thrift::protocol::T_I32, 6);
    xfer += oprot->writeI32(this->wVal);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.hwVal) {
    xfer += oprot->writeFieldBegin("hwVal", ::apache::thrift::protocol::T_I16, 7);
    xfer += oprot->writeI16(this->hwVal);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Value &a, Value &b) {
  using ::std::swap;
  swap(a.nVal, b.nVal);
  swap(a.bVal, b.bVal);
  swap(a.iVal, b.iVal);
  swap(a.fVal, b.fVal);
  swap(a.sVal, b.sVal);
  swap(a.wVal, b.wVal);
  swap(a.hwVal, b.hwVal);
  swap(a.__isset, b.__isset);
}

Value::Value(const Value& other45) {
  nVal = other45.nVal;
  bVal = other45.bVal;
  iVal = other45.iVal;
  fVal = other45.fVal;
  sVal = other45.sVal;
  wVal = other45.wVal;
  hwVal = other45.hwVal;
  __isset = other45.__isset;
}
Value& Value::operator=(const Value& other46) {
  nVal = other46.nVal;
  bVal = other46.bVal;
  iVal = other46.iVal;
  fVal = other46.fVal;
  sVal = other46.sVal;
  wVal = other46.wVal;
  hwVal = other46.hwVal;
  __isset = other46.__isset;
  return *this;
}
void Value::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Value(";
  out << "nVal="; (__isset.nVal ? (out << to_string(nVal)) : (out << "<null>"));
  out << ", " << "bVal="; (__isset.bVal ? (out << to_string(bVal)) : (out << "<null>"));
  out << ", " << "iVal="; (__isset.iVal ? (out << to_string(iVal)) : (out << "<null>"));
  out << ", " << "fVal="; (__isset.fVal ? (out << to_string(fVal)) : (out << "<null>"));
  out << ", " << "sVal="; (__isset.sVal ? (out << to_string(sVal)) : (out << "<null>"));
  out << ", " << "wVal="; (__isset.wVal ? (out << to_string(wVal)) : (out << "<null>"));
  out << ", " << "hwVal="; (__isset.hwVal ? (out << to_string(hwVal)) : (out << "<null>"));
  out << ")";
}


NewTag::~NewTag() noexcept {
}


void NewTag::__set_tag_id(const TagID val) {
  this->tag_id = val;
}

void NewTag::__set_props(const std::vector<Value> & val) {
  this->props = val;
}
std::ostream& operator<<(std::ostream& out, const NewTag& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t NewTag::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->tag_id);
          this->__isset.tag_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->props.clear();
            uint32_t _size47;
            ::apache::thrift::protocol::TType _etype50;
            xfer += iprot->readListBegin(_etype50, _size47);
            this->props.resize(_size47);
            uint32_t _i51;
            for (_i51 = 0; _i51 < _size47; ++_i51)
            {
              xfer += this->props[_i51].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.props = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t NewTag::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NewTag");

  xfer += oprot->writeFieldBegin("tag_id", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->tag_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("props", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->props.size()));
    std::vector<Value> ::const_iterator _iter52;
    for (_iter52 = this->props.begin(); _iter52 != this->props.end(); ++_iter52)
    {
      xfer += (*_iter52).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(NewTag &a, NewTag &b) {
  using ::std::swap;
  swap(a.tag_id, b.tag_id);
  swap(a.props, b.props);
  swap(a.__isset, b.__isset);
}

NewTag::NewTag(const NewTag& other53) {
  tag_id = other53.tag_id;
  props = other53.props;
  __isset = other53.__isset;
}
NewTag& NewTag::operator=(const NewTag& other54) {
  tag_id = other54.tag_id;
  props = other54.props;
  __isset = other54.__isset;
  return *this;
}
void NewTag::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "NewTag(";
  out << "tag_id=" << to_string(tag_id);
  out << ", " << "props=" << to_string(props);
  out << ")";
}


NewVertex::~NewVertex() noexcept {
}


void NewVertex::__set_id(const int64_t val) {
  this->id = val;
}

void NewVertex::__set_tags(const std::vector<NewTag> & val) {
  this->tags = val;
}
std::ostream& operator<<(std::ostream& out, const NewVertex& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t NewVertex::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->id);
          this->__isset.id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->tags.clear();
            uint32_t _size55;
            ::apache::thrift::protocol::TType _etype58;
            xfer += iprot->readListBegin(_etype58, _size55);
            this->tags.resize(_size55);
            uint32_t _i59;
            for (_i59 = 0; _i59 < _size55; ++_i59)
            {
              xfer += this->tags[_i59].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.tags = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t NewVertex::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NewVertex");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tags", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->tags.size()));
    std::vector<NewTag> ::const_iterator _iter60;
    for (_iter60 = this->tags.begin(); _iter60 != this->tags.end(); ++_iter60)
    {
      xfer += (*_iter60).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(NewVertex &a, NewVertex &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.tags, b.tags);
  swap(a.__isset, b.__isset);
}

NewVertex::NewVertex(const NewVertex& other61) {
  id = other61.id;
  tags = other61.tags;
  __isset = other61.__isset;
}
NewVertex& NewVertex::operator=(const NewVertex& other62) {
  id = other62.id;
  tags = other62.tags;
  __isset = other62.__isset;
  return *this;
}
void NewVertex::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "NewVertex(";
  out << "id=" << to_string(id);
  out << ", " << "tags=" << to_string(tags);
  out << ")";
}


AddVerticesRequest::~AddVerticesRequest() noexcept {
}


void AddVerticesRequest::__set_space_id(const GraphSpaceID val) {
  this->space_id = val;
}

void AddVerticesRequest::__set_parts(const std::map<PartitionID, std::vector<NewVertex> > & val) {
  this->parts = val;
}

void AddVerticesRequest::__set_prop_names(const std::map<TagID, std::vector<std::string> > & val) {
  this->prop_names = val;
}

void AddVerticesRequest::__set_if_not_exists(const bool val) {
  this->if_not_exists = val;
}
std::ostream& operator<<(std::ostream& out, const AddVerticesRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t AddVerticesRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->space_id);
          this->__isset.space_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->parts.clear();
            uint32_t _size63;
            ::apache::thrift::protocol::TType _ktype64;
            ::apache::thrift::protocol::TType _vtype65;
            xfer += iprot->readMapBegin(_ktype64, _vtype65, _size63);
            uint32_t _i67;
            for (_i67 = 0; _i67 < _size63; ++_i67)
            {
              PartitionID _key68;
              xfer += iprot->readI32(_key68);
              std::vector<NewVertex> & _val69 = this->parts[_key68];
              {
                _val69.clear();
                uint32_t _size70;
                ::apache::thrift::protocol::TType _etype73;
                xfer += iprot->readListBegin(_etype73, _size70);
                _val69.resize(_size70);
                uint32_t _i74;
                for (_i74 = 0; _i74 < _size70; ++_i74)
                {
                  xfer += _val69[_i74].read(iprot);
                }
                xfer += iprot->readListEnd();
              }
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.parts = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->prop_names.clear();
            uint32_t _size75;
            ::apache::thrift::protocol::TType _ktype76;
            ::apache::thrift::protocol::TType _vtype77;
            xfer += iprot->readMapBegin(_ktype76, _vtype77, _size75);
            uint32_t _i79;
            for (_i79 = 0; _i79 < _size75; ++_i79)
            {
              TagID _key80;
              xfer += iprot->readI32(_key80);
              std::vector<std::string> & _val81 = this->prop_names[_key80];
              {
                _val81.clear();
                uint32_t _size82;
                ::apache::thrift::protocol::TType _etype85;
                xfer += iprot->readListBegin(_etype85, _size82);
                _val81.resize(_size82);
                uint32_t _i86;
                for (_i86 = 0; _i86 < _size82; ++_i86)
                {
                  xfer += iprot->readBinary(_val81[_i86]);
                }
                xfer += iprot->readListEnd();
              }
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.prop_names = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->if_not_exists);
          this->__isset.if_not_exists = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AddVerticesRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("AddVerticesRequest");

  xfer += oprot->writeFieldBegin("space_id", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->space_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("parts", ::apache::thrift::protocol::T_MAP, 2);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I32, ::apache::thrift::protocol::T_LIST, static_cast<uint32_t>(this->parts.size()));
    std::map<PartitionID, std::vector<NewVertex> > ::const_iterator _iter87;
    for (_iter87 = this->parts.begin(); _iter87 != this->parts.end(); ++_iter87)
    {
      xfer += oprot->writeI32(_iter87->first);
      {
        xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(_iter87->second.size()));
        std::vector<NewVertex> ::const_iterator _iter88;
        for (_iter88 = _iter87->second.begin(); _iter88 != _iter87->second.end(); ++_iter88)
        {
          xfer += (*_iter88).write(oprot);
        }
        xfer += oprot->writeListEnd();
      }
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("prop_names", ::apache::thrift::protocol::T_MAP, 3);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I32, ::apache::thrift::protocol::T_LIST, static_cast<uint32_t>(this->prop_names.size()));
    std::map<TagID, std::vector<std::string> > ::const_iterator _iter89;
    for (_iter89 = this->prop_names.begin(); _iter89 != this->prop_names.end(); ++_iter89)
    {
      xfer += oprot->writeI32(_iter89->first);
      {
        xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(_iter89->second.size()));
        std::vector<std::string> ::const_iterator _iter90;
        for (_iter90 = _iter89->second.begin(); _iter90 != _iter89->second.end(); ++_iter90)
        {
          xfer += oprot->writeBinary((*_iter90));
        }
        xfer += oprot->writeListEnd();
      }
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("if_not_exists", ::apache::thrift::protocol::T_BOOL, 4);
  xfer += oprot->writeBool(this->if_not_exists);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(AddVerticesRequest &a, AddVerticesRequest &b) {
  using ::std::swap;
  swap(a.space_id, b.space_id);
  swap(a.parts, b.parts);
  swap(a.prop_names, b.prop_names);
  swap(a.if_not_exists, b.if_not_exists);
  swap(a.__isset, b.__isset);
}

AddVerticesRequest::AddVerticesRequest(const AddVerticesRequest& other91) {
  space_id = other91.space_id;
  parts = other91.parts;
  prop_names = other91.prop_names;
  if_not_exists = other91.if_not_exists;
  __isset = other91.__isset;
}
AddVerticesRequest& AddVerticesRequest::operator=(const AddVerticesRequest& other92) {
  space_id = other92.space_id;
  parts = other92.parts;
  prop_names = other92.prop_names;
  if_not_exists = other92.if_not_exists;
  __isset = other92.__isset;
  return *this;
}
void AddVerticesRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "AddVerticesRequest(";
  out << "space_id=" << to_string(space_id);
  out << ", " << "parts=" << to_string(parts);
  out << ", " << "prop_names=" << to_string(prop_names);
  out << ", " << "if_not_exists=" << to_string(if_not_exists);
  out << ")";
}


