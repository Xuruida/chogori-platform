// This autogenerated skeleton file illustrates how to build a server.
// You should copy it to another filename to avoid overwriting it.

#include <k2/appbase/AppEssentials.h>
#include <k2/appbase/Appbase.h>
#include <k2/cpo/client/CPOClient.h>
#include <k2/module/k23si/client/k23si_client.h>
#include <seastar/core/sleep.hh>


#include <k2/module/k23si/Module.h>
#include <k2/dto/K23SI.h>
#include <k2/dto/K23SIInspect.h>
#include <k2/dto/Collection.h>
#include <k2/dto/ControlPlaneOracle.h>
#include <k2/dto/MessageVerbs.h>

using namespace k2;

#include "Log.h"


#include "MetaService.h"
#include <thrift/protocol/TBinaryProtocol.h>
#include <thrift/server/TSimpleServer.h>
#include <thrift/transport/TServerSocket.h>
#include <thrift/transport/TBufferTransports.h>

using namespace ::apache::thrift;
using namespace ::apache::thrift::protocol;
using namespace ::apache::thrift::transport;
using namespace ::apache::thrift::server;


int32_t tag_exitcode;

const char* collname = "skv_collection";
const char* scname = "skv_schema";


class CreateTagHandler {
public: // application lifespan
    CreateTagHandler(const CreateTagReqTest& req) { K2LOG_I(log::k23si, "ctor"); _req=req;}
    ~CreateTagHandler() {K2LOG_I(log::k23si, "dtor"); }

    // required for seastar::distributed interface
    seastar::future<> gracefulStop() {
        K2LOG_I(log::k23si, "stop");
        return std::move(_testFuture);
    }

    seastar::future<> start() {
        
    K2LOG_I(log::k23si, "+++++++ start schema creation test +++++++");
    ConfigVar<String> configEp("cpo_endpoint");
    _cpoEndpoint = RPC().getTXEndpoint(configEp());

    // let start() finish and then run the tests
    _testTimer.set_callback([this] {
        _testFuture = runScenario00()
           .then([this] {
            K2LOG_I(log::k23si, "======= All tests passed ========");
            exitcode = 0;
        })
    .handle_exception([this](auto exc) {
            try {
                std::rethrow_exception(exc);
            } catch (RPCDispatcher::RequestTimeoutException& exc) {
                K2LOG_E(log::k23si, "======= Test failed due to timeout ========");
                exitcode = -1;
            } catch (std::exception& e) {
                K2LOG_E(log::k23si, "======= Test failed with exception [{}] ========", e.what());
                exitcode = -1;
            }
        })
        .finally([this] {
            K2LOG_I(log::k23si, "======= Test ended ========");
            seastar::engine().exit(exitcode);
         
        });
    });
    _testTimer.arm(0ms);
        return seastar::make_ready_future<>();
}

private:
    std::unique_ptr<k2::TXEndpoint> _cpoEndpoint;
    k2::ConfigVar<std::vector<k2::String>> _k2ConfigEps{"k2_endpoints"};
    seastar::future<> _testFuture = seastar::make_ready_future();

    seastar::timer<> _testTimer;

    CreateTagReqTest _req;

    int exitcode = -1;

    seastar::future<> createCollection(){
        K2LOG_I(log::k23si, "create a collection with assignments");

        auto request = dto::CollectionCreateRequest{
            .metadata{
                .name = collname,
                .hashScheme=dto::HashScheme::HashCRC32C,
                .storageDriver=dto::StorageDriver::K23SI,
                .capacity{
                    .dataCapacityMegaBytes = 100,
                    .readIOPs = 100000,
                    .writeIOPs = 100000
                },
                .retentionPeriod = 5h
            },
            .clusterEndpoints = _k2ConfigEps(),
            .rangeEnds{}
        };
        return RPC()
            .callRPC<dto::CollectionCreateRequest, dto::CollectionCreateResponse>(dto::Verbs::CPO_COLLECTION_CREATE, request, *_cpoEndpoint, 1s)
            .then([](auto&& response) {
                // create the collection
                auto& [status, resp] = response;
                K2EXPECT(log::k23si, status, Statuses::S201_Created);
            })
            .then([] {
                // wait for collection to get assigned
                return seastar::sleep(200ms);
            })
            .then([this] {
                // check to make sure the collection is assigned
                auto request = dto::CollectionGetRequest{.name = collname};
                return RPC()
                    .callRPC<dto::CollectionGetRequest, dto::CollectionGetResponse>(dto::Verbs::CPO_COLLECTION_GET, request, *_cpoEndpoint, 100ms);
            })
             .then([this](auto&& response) {
                auto& [status, resp] = response;
                K2EXPECT(log::k23si, status, Statuses::S200_OK);
                K2EXPECT(log::k23si, resp.collection.metadata.name, collname);
                K2EXPECT(log::k23si, resp.collection.metadata.hashScheme, dto::HashScheme::HashCRC32C);
                K2EXPECT(log::k23si, resp.collection.metadata.storageDriver, dto::StorageDriver::K23SI);
                K2EXPECT(log::k23si, resp.collection.metadata.retentionPeriod, 5h);
                K2EXPECT(log::k23si, resp.collection.metadata.capacity.dataCapacityMegaBytes, 100);
                K2EXPECT(log::k23si, resp.collection.metadata.capacity.readIOPs, 100000);
                K2EXPECT(log::k23si, resp.collection.metadata.capacity.writeIOPs, 100000);
                K2EXPECT(log::k23si, resp.collection.partitionMap.version, 1);
                K2EXPECT(log::k23si, resp.collection.partitionMap.partitions.size(), 3);

                // how many partitions we have
                uint64_t numparts = _k2ConfigEps().size();
                auto max = std::numeric_limits<uint64_t>::max();
                // how big is each one
                uint64_t partSize = max / numparts;

                for (size_t i = 0; i < resp.collection.partitionMap.partitions.size(); ++i) {
                    auto& p = resp.collection.partitionMap.partitions[i];
                    K2EXPECT(log::k23si, p.keyRangeV.pvid.rangeVersion, 1);
                    K2EXPECT(log::k23si, p.astate, dto::AssignmentState::Assigned);
                    K2EXPECT(log::k23si, p.keyRangeV.pvid.assignmentVersion, 1);
                    K2EXPECT(log::k23si, p.keyRangeV.pvid.id, i);
                    K2EXPECT(log::k23si, p.keyRangeV.startKey, std::to_string(i * partSize));
                    K2EXPECT(log::k23si, p.keyRangeV.endKey, std::to_string(i == _k2ConfigEps().size() - 1 ? max : (i + 1) * partSize - 1));
                    K2EXPECT(log::k23si, *p.endpoints.begin(), _k2ConfigEps()[i]);
                }
            });

    }




public: // tests

seastar::future<> runScenario00() {
    K2LOG_I(log::k23si, "+++++++ Schema Creation Test 00: initiate a schema with partition&range key +++++++");
    K2LOG_I(log::k23si, "STEP1: assign a collection named {}", collname);

    // step 1
    return createCollection()
    // step 2
    .then([this] {
        K2LOG_I(log::k23si, "------- create collection success. -------");
        K2LOG_I(log::k23si, " create a shema of vertex with fixed fields {{Type | PartID | VertexID | TagID}}");
        

        dto::Schema schema ;
       // std::string collname=_req.space_name;
       // schema.name = _req.tag_name;
        schema.name = scname;
        schema.version = 1;
        
        schema.fields = std::vector<dto::SchemaField> {
                {dto::FieldType::INT16T, "Type", false, false},
                {dto::FieldType::INT16T, "PartID", false, false},
                {dto::FieldType::INT64T, "VertexID", false, false},
                {dto::FieldType::INT32T, "TagID", false, false}
        };
        
      
        schema.setPartitionKeyFieldsByName(std::vector<String>{"Type","PartID"});
        schema.setRangeKeyFieldsByName(std::vector<String> {"VertexID","TagID"});

        dto::CreateSchemaRequest request{ collname, std::move(schema) };
        return RPC().callRPC<dto::CreateSchemaRequest, dto::CreateSchemaResponse>(dto::Verbs::CPO_SCHEMA_CREATE, request, *_cpoEndpoint, 1s)
        .then([this] (auto&& response) {
            auto& [status, resp] = response;
            K2EXPECT(log::k23si, status, Statuses::S200_OK);

            dto::GetSchemasRequest request { collname };
            return RPC().callRPC<dto::GetSchemasRequest, dto::GetSchemasResponse>(dto::Verbs::CPO_SCHEMAS_GET, request, *_cpoEndpoint, 1s);
        })
        .then([] (auto&& response) {
            auto& [status, resp] = response;
            K2EXPECT(log::k23si, status, Statuses::S200_OK);
            K2EXPECT(log::k23si, resp.schemas.size(), 1);
            K2EXPECT(log::k23si, resp.schemas[0].name, scname);

            K2LOG_I(log::k23si, "------- create schema success. -------");
            return seastar::make_ready_future<>();
        });
    });
}

};













class MetaServiceHandler : virtual public MetaServiceIf {
 public:
  MetaServiceHandler(int argc, char **argv) {_argc = argc; _argv = argv;}



  int32_t createTag(const CreateTagReqTest& req) {
    // Your implementation goes here
   
    App app( "CreateTagHandlerTest");

    app.addOptions()("k2_endpoints", bpo::value<std::vector<k2::String>>()->multitoken(), "The endpoints of the k2 cluster");
    app.addOptions()("cpo_endpoint", bpo::value<k2::String>(), "The endpoint of the CPO");
      
  //  app.addApplet<TSO_ClientLib>();

    app.addApplet<CreateTagHandler>(req);
    app.start(_argc, _argv);
    return tag_exitcode;

    printf("createTag\n");
  }


   int32_t add(const int32_t num1, const int32_t num2) {
    // Your implementation goes here

    return num1+num2;
    printf("add\n");
  }
  
  private:
    int _argc;
    char **_argv;
};










int main(int argc, char **argv) {

  int port = 9090;
  ::std::shared_ptr<MetaServiceHandler> handler(new MetaServiceHandler(argc,argv));
  ::std::shared_ptr<TProcessor> processor(new MetaServiceProcessor(handler));
  ::std::shared_ptr<TServerTransport> serverTransport(new TServerSocket(port));
  ::std::shared_ptr<TTransportFactory> transportFactory(new TBufferedTransportFactory());
  ::std::shared_ptr<TProtocolFactory> protocolFactory(new TBinaryProtocolFactory());

  TSimpleServer server(processor, serverTransport, transportFactory, protocolFactory);
  server.serve();

  return 0;
}


